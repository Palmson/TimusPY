from sys import stdin


def main():  # функция нужна, чтобы быстрее работать с локальными переменными
    m, n = map(int, stdin.readline().split())  # считываем данные с помощью встроенного быстрого ввода
    arr = [stdin.readline() for _ in range(n)]
    st = -1
    graph = [0 for _ in range(n * m)]  # создаем граф на клетках
    per = [(-1, 0), (0, 1), (0, -1), (1, 0)]  # массив переходов в соседние клетки, первое число в паре изменение номера строки, второе изменение номера столбца

    # хранить клетку (i, j) для скорости будем как i * m + j
    for i in range(n):
        for j in range(m):
            if arr[i][j] == '.':  # строим граф на пустых клетках
                if st == -1:  # находим любую пустую клетку
                    st = i * m + j
                for k in range(4):  # перебираем соседей
                    new_i = i + per[k][0]
                    new_j = j + per[k][1]
                    if 0 <= new_i and new_i < n and 0 <= new_j and new_j < m and arr[new_i][new_j] == '.':  #запоминаем что есть ребро, для этого кодируем соседей как число от 0 до 15 и бит i обознчает что есть переход i
                        graph[i * m + j] |= (1 << k)

    # для поиска диаметра в дереве будем использовать следующий алгоритм: запустим поиск диаметра из любой вершины
    # найдем наиболее удаленную вершину и затем из нее найдем наиболее удаленную
    print(st)
    # для поиска расстояний от вершины будем использовать алгоритм поиска в ширину(BFS)
    dist = [10 ** 9] * (n * m)  # создаем массив расстояний от вершины, изначально заполняем бесконечностью
    dq = [0] * n * m  # создаем очередь на массиве
    ind1 = 0
    ind2 = 1
    dq[ind1] = st  # кладем в начало вершину и делаем у нее расстояние 0
    dist[st] = 0
    while ind1 < ind2:  # пока в очереди есть элементы
        v = dq[ind1]  # достаем из начало вершину
        ind1 += 1
        for k in range(4):
            if (1 << k) & graph[v]:  # перебираем ее соседей
                to = v

                # так как если (i, j) переходит в (i + 1, j), то i * m + j -> i * m + m + j = i * m + j + m
                # можем записать это для остальных переходов и поэтому две формулы снизу работают
                to += per[k][0] * m
                to += per[k][1]

                if dist[to] > dist[v] + 1:  # если у нее можем обновить расстояние, то обновляем и добавляем в очередь
                    dist[to] = dist[v] + 1
                    dq[ind2] = to
                    ind2 += 1
    st = dq[ind1 - 1]  # клетка с максимальным расстояениям была последней в очереди, поэтому достанем ее оттуда
    print(dq)
    print(dist)
    dist = [10 ** 9] * (n * m)
    print(st)
    # теперь надо повторить алгоритм для нового старта, так как тоже самое, то повторять комментарии не буду

    ind1 = 0
    ind2 = 1
    dq[ind1] = st
    dist[st] = 0
    ans = 0
    while ind1 < ind2:
        v = dq[ind1]
        ans = max(dist[v], ans)
        ind1 += 1
        for k in range(4):
            if (1 << k) & graph[v]:
                to = v
                to += per[k][0] * m
                to += per[k][1]
                if dist[to] > dist[v] + 1:
                    dist[to] = dist[v] + 1
                    dq[ind2] = to
                    ind2 += 1
    print(ans)  # выводим ответ
    print(dq)
    print(dist)

main()